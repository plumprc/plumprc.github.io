---
title: 洛谷之旅（三）
category: ACM
tags:
- ACM
- 算法
---

|前导
|:-:
|并查集
|离散化
|哈希

## 并查集
&emsp;&emsp;并查集是多棵多叉树，每棵多叉树代表一个集合，记录了祖先和孩子的对应关系。为减少查询所花费的时间，我们可以对树进行**路径压缩**，让所有的孩子结点直接指向根结点，这样在查询关系时只需要判断两者的祖先是否一致即可。
```c++
int a[5005];

int query(int pos){
    int root = pos, tmp;
    while(root != a[root])
        root = a[root]; // 找祖先
    // 路径压缩
    while(pos != a[pos]){
        tmp = a[pos];
        a[pos] = root;
        pos = tmp;
    }
    return root;
}

for(int i = 1; i <= n; i++)
    a[i] = i; // 初始每个人自成一个集合
```

&emsp;&emsp;反集思想：并查集的空间开辟为原来的二倍，实现敌人的敌人就是朋友
```c++
if(c == 'F')
    a[query(p)] = query(q);
else{
    a[query(p + n)] = query(q);
    a[query(q + n)] = query(p);
}
```

## 离散化
&emsp;&emsp;离散化，把无限空间中有限的个体映射到有限的空间中去。题目中出现上界为 `1e+9` 左右的非密集数据时，直接开辟相应大小的数组显然会 MLE，且浪费大量的空间。这时候我们就需要进行离散化将原始数据映射到新的数组内。通常我们有两种方法来实现离散化：

&emsp;&emsp;利用 `algorithm`，实现排序、去重、定位：
```c++
int n, a[MAX], t[MAX];
int main(){
    cin >> n;
    for(int i = 1; i <= n; i++)
        // {6, 8, 4, 6, 9, 5, 8}
        cin >> a[i], t[i] = a[i];
    sort(t + 1, t + n + 1);
    // {4, 5, 6, 8, 9, 6, 8}，unique 去除相邻重复元素
    int cps = unique(t + 1, t + n + 1) - t - 1;
    for(int i = 1; i <= n; i++){
        // {3, 4, 1, 3, 5, 2, 4}
        a[i] = lower_bound(t + 1, t + cps + 1, a[i]) - t;
    }
}
```

&emsp;&emsp;结构体离散化去重：
```c++
int n, T, cps;
struct node{
    int val, id;
    inline bool operator<(const node &t) const{
        return val < t.val || val == t.val && id < t.id;
    }
    inline bool operator==(const node &t) const{
        return val == t.val;
    }
}a[500005];

inline bool cmp(node a, node b){
    return a.id < b.id;
}

int main(){
    cin >> T;
    while(T--){
        scanf("%d", &n);
        for(int i = 1; i <= n; i++){
            scanf("%d", &a[i].val);
            a[i].id = i;
        }
        sort(a + 1, a + 1 + n);
        cps = unique(a + 1, a + 1 + n) - a - 1;
        sort(a + 1, a + 1 + cps, cmp);
        for(int i = 1; i <= cps; i++)
            printf("%d ", a[i].val);
        printf("\n");
    }
    return 0;
}
```

&emsp;&emsp;注：离散化往往会面临大量数据的读取，此时不要用流，使用朴素的 `scanf` 或者快读会大大提速。

## 哈希
&emsp;&emsp;与离散化相似，面对跨度极大的稀疏数据，开辟过大的连续数组往往会 TLE/MLE，此时我们需要使用哈希法实现数据的重映射。手写哈希的关键点在于模数，模数选择为大于数据上界的素数（131，233，19260817，100007），为减少冲突，模数需要选的尽可能的大。

&emsp;&emsp;解决冲突的方法：
* 分离链接法
* 开放定址法
  * 线性探测法（一次聚集）
  * 平方探测法（二次聚集）
* 双散列、再散列

```c++
#define mod 100007
vector<int> Hash[100005]; // 链表哈希
int maxx; // 搜索上界
bool check(int val){
    // 防止出现负数下标
    int pos = (val % mod + mod) % mod;
    maxx = max(maxx, pos);
    for(int i = 0; i < Hash[pos].size(); i++){
        if(Hash[pos][i] == val)
            return true;
    }
    Hash[pos].push_back(val);
    return false;
}
```

&emsp;&emsp;STL 有内置哈希 `map`，底层由红黑树实现，判断是 O(logn)
```c++
map<int, int> mat;
mat[5] = 3;
mat.erase(5);
```

&emsp;&emsp;map有时会被卡掉，这时候可以换用 `unordered_map`，底层实现为哈希，判断是 O(1)
```c++
unordered_map<string, int> mat;
mat.clear();
```

### 字符串哈希
&emsp;&emsp;字符串的存储和比较是既耗时又耗空间的操作。哈希法就是将字符串映射为整数，对整数进行存储和比较可以大大减少消耗。因此关键在于找到合适的哈希函数使得该映射尽量为单射。

&emsp;&emsp;两个字符的哈希示例：
```c++
string s;
int A = s[0] * 26 + s[1];
```

&emsp;&emsp;自然溢出法：利用 `unsigned long long` 的范围自然溢出，相当于自动对 $2^{64}-1$ 取模

```c++
typedef unsigned long long ull;
ull a[MAX]; ull base = 131; // 19260817

ull hash(string s){
    ull val = 1;
    int len = s.size();
    for(int i = 0; i < len; i++){
        val = val * base + (ull)s[i];
    }
    return val;
}
```