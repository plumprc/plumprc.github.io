---
title: 洛谷之旅（四）
category: ACM
tags:
- ACM
- 算法
---

|前导
|:-:
|排序、递归
|贪心
|二分答案
|搜索

## 排序
&emsp;&emsp;计数排序，桶排序的特殊情形
```c++
int n, m, num, a[1000];

int main(){
    cin >> n >> m;
    while(m--){
        scanf("%d", &num);
        a[num]++;
    }
    for(int i = 1; i <= n; i++){
        while(a[i]--)
            printf("%d ", i);
    }
    return 0;
}
```

&emsp;&emsp;快速排序，选基准，二分排
```c++
void qsort(int L, int R){
    int mid = L + (R - L) / 2;
    int i = L, j = R;
    do{
        while(a[i] < a[mid]) i++;
        while(a[j] > a[mid]) j--;
        if(i <= j){
            swap(a[i], a[j]);
            i++; j--;
        }
    }while(i <= j);
    if(i < R) qsort(i, R);
    if(j > L) qsort(L, j);
}
```

&emsp;&emsp;寻找第 K 大/小元素，内核与快排相同，选基准后二分
```c++
void findK(int L, int R){
    int mid = L + (R - L) / 2;
    int i = L, j = R;
    do{
        while(a[i] < a[mid]) i++;
        while(a[j] > a[mid]) j--;
        if(i <= j){
            swap(a[i], a[j]);
            i++; j--;
        }
    }while(i <= j);
    if(k <= j) findK(L, j);
    else if(i <= k) findK(i, R);
    else{
        printf("%d", a[j + 1]);
        return;
    }
}
```

&emsp;&emsp;结构体排序
```c++
struct node{
    int id, x;
    string s;
    inline bool operator<(const node& t) const{
        return x < t.x;
    }
}p[maxn];

sort(p, p + n);
```

&emsp;&emsp;注意 `sort` 为不稳定排序，若希望处理相同元素时不改变下标，请使用稳定排序 `stable_sort`

## 递归的妙用
&emsp;&emsp;字符串展开
```c++
// AC[2[2FUN]] == ACFUNFUNFUNFUN
string readS(){
    int n; char c;
    string s = "", s1;
    while(cin >> c){
        if(c == '['){
            cin >> n;
            s1 = readS();
            while(n--) s += s1;
        }
        else{
            if(c == ']') return s;
            else s += c;
        }
    }
    return s;
}
```

&emsp;&emsp;数制展开
```c++
string cvt(int x, int pow){
    string s = "";
    if(x == 0)
        return "0";
    
    do{
        if(x & 1)
            s = (pow == 1? "2" : "2(" + cvt(pow, 0) + ")") + (s == ""? "" : "+") + s;
    } while(pow++, x >>= 1);
    return s;
}
```

## 贪心
&emsp;&emsp;顾名思义，以贪心策略解决问题，往往需要预排序

&emsp;&emsp;线段覆盖问题
* 贪心策略：选择最右端尽量靠左的线段

```c++
struct node{
    int x, y;
    inline bool operator<(const node &t) const{
        return y < t.y;
    }
}line[maxx];

sort(line, line + n);
int rhs = line[0].y; res++;
for(int i = 1; i < n; i++){
    if(rhs <= line[i].x){
        rhs = line[i].y;
        res++;
    }
    else continue;
}
```

&emsp;&emsp;删数（选数）问题
* 贪心策略：选择可取的最左侧最小的数（最左侧 k + 1 个数一定至少要保留一个）

```c++
rest = len - k; // 保留
while(cnt < rest){
    minp = L;
    for(int i = L; i <= L + k; i++){
        if(a[i] < a[minp])
            minp = i;
    }
    if(a[minp]) flag = 1;
    if(flag) printf("%d", a[minp]);
    k -= minp - L; // 删数
    L = minp + 1;
    cnt++;
}
if(!flag) printf("0");
```

&emsp;&emsp;填坑问题
* 贪心策略：填大坑时相邻的小坑一定会被顺手填掉
* 注：这可以计算数组中所有山峰的净高度
```c++
for(int i = 1; i <= n; i++)
    a[i] = read();
for(int i = 1; i <= n; i++)
    if(a[i] > a[i - 1])
        res += a[i] - a[i - 1]; // 山峰的净高
cout << res;
```

## 二分答案
&emsp;&emsp;最常见的分治算法，显著的特征为解空间是单调的，关键词为最大（小）值最小（大），解题步骤为确定左右界后二分查找答案再判定
```c++
// STL
int resp = lower_bound(a, a + n, x) - a;
// 手写二分查找（答案一定存在）
int findx(int x, int len){
    int L = 0, R = len - 1;
    while(L < R){
        int mid = L + (R - L) / 2;
        if(a[mid] >= x)
            R = mid;
        else L = mid + 1;
    }
    if(a[L] == x) return L + 1;
    else return -1;
}
// 通用模板
while(L <= R){
    int mid = L + (R - L) / 2;
    if(judge(mid))
        L = mid + 1;
    else R = mid - 1;
}
cout << L - 1; // 注意输出形式
```
注意 `int mid = L + (R - L) / 2;` 这种写法，一能有效避免整型溢出，二是取整时上下界统一（靠近 L）

&emsp;&emsp;砍树问题，一次砍所有树木，求砍伐得到给定树木的木材时砍伐机的最高高度
```c++
for(int i = 0; i < n; i++){
    a[i] = read();
    R = max(R, a[i]); // 右界
}
while(L <= R){
    long long mid = L + (R - L) / 2, tmp = 0;
    for(int i = 0; i < n; i++)
        if(a[i] > mid)
            tmp += a[i] - mid;
    if(tmp < m)
        R = mid - 1;
    else L = mid + 1;
}
cout << L - 1;
```

## 搜索
### 暴力枚举
&emsp;&emsp;全排列问题（next_permutation）
```c++
int a[3] = {1, 2, 3};
do{
    printf("%d %d %d\n", &a[0], &a[1], &a[2]);
}
while(next_permutation(a, a + 3));
```

### dfs 的千层套路
```c++
bool visited[10]; int a[105];
vector<vector<int> > res;
vector<int> tmp;

// {1, 1, 1} -> {3, 3, 3}
void dfs(){
    if(tmp.size() == 3){
        res.push_back(tmp);
        return;
    }
    for(int i = 1; i <= 3; i++){
        tmp.push_back(i);
        dfs();
        tmp.pop_back();
    }
}

// 全排列（next_permutation）
void dfs(){
    if(tmp.size() == 3){
        res.push_back(tmp);
        return;
    }
    for(int i = 1; i <= 3; i++){
        if(!visited[i]){
            tmp.push_back(i);
            visited[i] = true;
            dfs();
            tmp.pop_back();
            visited[i] = false;
        }
    }
}

// 升降序扫描，无重排列
void dfs(int left){
    if(tmp.size() == 3){
        res.push_back(tmp);
        return;
    }
    for(int i = left; i <= 4; i++){
        if(!visited[i]){
            tmp.push_back(i);
            visited[i] = true;
            // 注意是 i + 1
            dfs(i + 1); // dfs(i) 为有重升降序
            tmp.pop_back();
            visited[i] = false;
        }
    }
}

// 含参约束
void dfs(int left, int sum){
    if(sum < 0) return;
    if(sum == 0){
        res++; return;
    }
    for(int i = left; i < n; i++){
        if(!visited[i]){
            visited[i] = true;
            dfs(i + 1, sum - a[i]);
            visited[i] = false;
        }    
    }
}
```

&emsp;&emsp;网格搜索
```c++
int dx[2] = {0, 1}, dy[2] = {1, 0};

void dfs(int x, int y, int i, int sum){
    if(sum > k){
        res++;
        return;
    }
    if(mat[x][y] != '.' || x < 0 || y < 0 || x >= n || y >= m)
        return;
    for(int k = 0; k < 2; k++)
        dfs(x + dx[k], y + dy[k], k, sum + 1);
}
```

&emsp;&emsp;始于八皇后，终于八皇后
* 空间优化：可以不使用二阶矩阵存储状态信息，而使用三个一维矩阵分别存储列、左对角和右对角三条直线上的信息

```c++
int a[105]; 
bool b[105], c[105], d[105];
void dfs(int i){
    if(i > n){
        print();
        return;
    }
    for(int j = 1; j <= n; j++){
        if((!b[j]) && (!c[i + j]) && (!d[i - j + n])){
            a[i] = j;
            b[j] = 1;
            c[i + j] = 1;
            d[i - j + n] = 1; // 防止下标为负
            dfs(i + 1);
            b[j] = 0;
            c[i + j] = 0;
            d[i - j + n] = 0;
        }
    }
}
```

&emsp;&emsp;水坑问题，搜索的同时染色以判断连通块
```c++
void dfs(int x, int y){
    c[x][y] = '.';
    for(int i = 0; i < 8; i++){
        nx = x + dx[i], ny = y + dy[i];
        if(nx > 0 && ny > 0 && nx <= n && ny <= m && c[nx][ny] == 'W')
            dfs(nx, ny);
    }
}
```

### 遇事不决 bfs
&emsp;&emsp;马的遍历
* 当 dfs 的出点不好寻找时，可以考虑 bfs，同时 bfs 也可以方便的记录搜索的深度

```c++
struct node{
    int x, y;
}p, t;

void bfs(int x, int y, int step){
    a[x][y] = step;
    queue<node> q;
    p.x = x, p.y = y;
    q.push(p);
    while(!q.empty()){
        t = q.front();
        q.pop();
        for(int i = 0; i < 4; i++){
            for(int j = 0; j < 4; j++){
                if(abs(dx[i]) != abs(dy[j])){
                    int px = t.x + dx[i];
                    int py = t.y + dy[j];
                    if(px < 1 || py < 1 || px > n || py > m)
                        continue;
                    if(a[px][py] == -1){
                        p.x = px, p.y = py;
                        a[px][py] = a[t.x][t.y] + 1;
                        q.push(p);
                    }
                }
            }
        }
    }
}
```

&emsp;&emsp;电梯问题，电梯有上下两种操作，每层上或下的步长是固定的，求从起点到终点最少需要操纵几次电梯
* 对于大部分涉及搜索层数的问题，bfs 的性能要优于 dfs，因为 dfs 存在多次回溯
* 注意为了保存深度我们一般会用一个结构体来存储状态信息
```c++
int n, res = INT_MAX, L, R, a[205];
bool vis[205];

void dfs(int pos, int step){
    if(pos == R)
        res = min(res, step);
    if(step > res) return;
    vis[pos] = 1;
    if(pos + a[pos] <= n && !vis[pos + a[pos]])
        dfs(pos + a[pos], step + 1);
    if(pos - a[pos] >= 1 && !vis[pos - a[pos]])
        dfs(pos - a[pos], step + 1);
    vis[pos] = 0;
}

struct node{
    int id, step;
}p;

void bfs(int pos){
    queue<node> q;
    q.push((node) {pos, 0});
    while(!q.empty()){
        p = q.front();
        q.pop();
        if(p.id == R)
            break;
        if(p.id + a[p.id] <= n && !vis[p.id + a[p.id]]){
            q.push((node) {p.id + a[p.id], p.step + 1});
            vis[p.id + a[p.id]] = 1;
        }
        if(p.id - a[p.id] >= 1 && !vis[p.id - a[p.id]]){
            q.push((node) {p.id - a[p.id], p.step + 1});
            vis[p.id - a[p.id]] = 1;
        }
    }
}
```