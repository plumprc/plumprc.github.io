---
title: 洛谷之旅（二）
category: ACM
tags:
- ACM
- 算法
---

|前导
|:-:
|线性表、二叉树
|二叉搜索树
|伸展树

## 线性表
### 链表
&emsp;&emsp;数组的查找为线性时间，而插入和删除的花费是昂贵的。为了避免插入和删除的线性开销，我们需要表可以不连续存储，这就是链表。

```c++
const int MAX = 1e5 + 5;
struct node{
    int L, R;
    int flag; // lazy del
} list[MAX];

void add(int pos, int k){
    list[k].R = list[pos].R;
    list[k].L = pos;
    list[pos].R = k;
    list[list[k].R].L = k;
}

list[0].L = list[0].R = 0; // 头结点

for(int i = list[0].R; i ; i = list[i].R){
    if(list[i].flag == 0)
        cout << i << ' ';
}
```

&emsp;&emsp;桶排序：准备一个桶 `int cnt[MAX]`，读入数字时 `cnt[a]++`

&emsp;&emsp;基数排序：借助链表，最低位优先进行多次桶排序

### 栈（FIFO）
&emsp;&emsp;后缀表达式解析
```c++
stack<int> s;
char c; int n, x, y;

int main(){
    cin >> n;
    while(c != '@'){
        cin >> c;
        switch(c){
            case '+' : x = s.top(); s.pop(); y = s.top(); s.pop(); s.push(x + y); break;
            case '-' : x = s.top(); s.pop(); y = s.top(); s.pop(); s.push(y - x); break;
            case '*' : x = s.top(); s.pop(); y = s.top(); s.pop(); s.push(x * y); break;
            case '/' : x = s.top(); s.pop(); y = s.top(); s.pop(); s.push(y / x); break;
            case '.' : s.push(n); n = 0; break;
            default : n = n * 10 + c - '0'; break;
        }
    }
    cout << s.top();
    return 0;
}
```

&emsp;&emsp;可能栈序列
```c++
int q, n, pos;
int a[100005], b[100005];

int main(){
    cin >> q;
    while(q--){
        cin >> n;
        for(int i = 0; i < n; i++)
            cin >> a[i];
        for(int i = 0; i < n; i++)
            cin >> b[i];
        for(int i = 0; i < n; i++){
            s.push(a[i]);
            while(s.top() == b[pos]){
                s.pop(); pos++;
                if(s.empty()) break;
            }
        }
        cout << (s.empty()? "Yes" : "No") << endl;
        while(!s.empty())
            s.pop();
    }
    return 0;
}
```

&emsp;&emsp;出栈可能种数：卡特兰数
$$C_n=\frac{1}{n+1}\binom{2n}{n}=\frac{2n!}{(n+1)!n!}$$

&emsp;&emsp;括号补全骚操作
```c++
int id(char c){
    switch(c){
        case '(' : return -2;
        case '[' : return -1;
        case ']' : return 1;
        case ')' : return 2;
        default  : return 0;
    }
}

void print(int a){
    if(a == 1 || a == -1)
        printf("[]");
    else if(a == 2 || a == -2)
        printf("()");
}
```

### 队列（FILO）
&emsp;&emsp;约瑟夫问题
```c++
int n, m, pos = 1;
queue<int> q;

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) q.push(i);
    while(!q.empty()){
        if(pos == m){
            cout << q.front() << ' ';
            q.pop();
            pos = 1;
        }
        else{
            pos++;
            q.push(q.front());
            q.pop();
        }
    }
    return 0;
}
```

&emsp;&emsp;要注意 C++ 迭代器（iterator）用于对数据结构中的元素进行顺序访问或随机访问。因此，对于根据定义不允许顺序或随机访问的数据结构，迭代器没有任何意义。这就是堆栈和队列没有迭代器的原因。（vector 赛高！）

## 树
### 完全二叉树
```c++
struct node{
    int L, R;
}biTree[MAX];
```

&emsp;&emsp;二叉树的深度、宽度、最近公共祖先（lca）、内部结点距离
```c++
int depth(int pos){
    if(pos == 0) return 0;
    return 1 + max(depth(tree[pos].L), depth(tree[pos].R));
}

int cnt[110]; // 桶排
void width(int pos, int level, int* cnt){
    if(pos == 0) return;
    cnt[level]++;
    width(tree[pos].L, level + 1, cnt);
    width(tree[pos].R, level + 1, cnt);
}

int lca(int root, int p, int q){
    if(root == 0) return 0;
    if(root == p || root == q)
        return root;
    int left = lca(tree[root].L, p, q);
    int right = lca(tree[root].R, p, q);
    if(left != 0 && right != 0)
        return root;
    if(left == 0 && right != 0) return right;
    if(left != 0 && right == 0) return left;
    return 0;
}

int dis(int root, int pos, int d){
    if(root == 0) return 0;
    if(root == pos) return d;
    int l_dis = dis(tree[root].L, pos, d + 1);
    int r_dis = dis(tree[root].R, pos, d + 1);
    return max(l_dis, r_dis);
}
// int llca = lca(root, pos1, pos2);
// d(pos1, pos2) = dis(root, pos1, 0) + dis(root, pos2, 0) - 2 * dis(root, llca, 0);
```

&emsp;&emsp;前序、中序、后序遍历问题

&emsp;&emsp;给定一棵二叉树的前序和后序遍历，不能确定中序遍历序列；其他情况可以确定
```c++
void postOrder(string in, string pre){
    if(pre.size() == 0)
        return;
    int pos = in.find(pre[0]);
    postOrder(in.substr(0, pos), pre.substr(1, pos));
    postOrder(in.substr(pos + 1), pre.substr(pos + 1));
    cout << pre[0];
}

void preOrder(string in, string post){
    if(post.size() == 0)
        return;
    int len = post.size() - 1;
    int pos = in.find(post[len]);
    cout << post[len];
    preOrder(in.substr(0, pos), post.substr(0, pos));
    preOrder(in.substr(pos + 1), post.substr(pos, len - pos));
}

// 只有一棵子树时出现歧义
int inOrderCnt(string pre, string post){
    int res = 1;
    int len = pre.size();
    for(int i = 0; i < len - 1; i++){
        for(int j = 1; j < len; j++){
            if(a[i] == b[j] && a[i + 1] == b[j - 1])
                res *= 2;
        }
    }
    return res;
}
```

### 二叉搜索树（BST）
```c++
int bnt;
struct node{
    int val, L, R, cnt, siz;
}BST[MAX];

void add(int pos, int val){
    BST[pos].siz++;
    if(BST[pos].val == val){
        BST[pos].cnt++;
        return;
    }
    if(BST[pos].val > val){
        if(BST[pos].L != 0)
            add(BST[pos].L, val);
        else{
            bnt++; // BST结点总数
            BST[bnt].val = val;
            BST[bnt].siz = BST[bnt].cnt = 1;
            BST[pos].L = bnt;
        }
    }
    else{
        if(BST[pos].R != 0)
            add(BST[pos].R, val);
        else{
            bnt++;
            BST[bnt].val = val;
            BST[bnt].siz = BST[bnt].cnt = 1;
            BST[pos].R = bnt;
        }
    }
}

int queryPre(int pos, int val, int res){
    if(BST[pos].val >= val){
        if(BST[pos].L == 0)
            return res;
        else return queryPre(BST[pos].L, val, res);
    }
    else{
        if(BST[pos].R == 0)
            return (BST[pos].val < val? BST[pos].val : res);
        if(BST[pos].cnt != 0)
            return queryPre(BST[pos].R, val, BST[pos].val);
        else return queryPre(BST[pos].R, val, res);
    }
}

int queryPost(int pos, int val, int res){
    if(BST[pos].val <= val){
        if(BST[pos].R == 0)
            return res;
        else return queryPost(BST[pos].R, val, res);
    }
    else{
        if(BST[pos].L == 0)
            return (BST[pos].val > val? BST[pos].val : res);
        if(BST[pos].cnt != 0)
            return queryPost(BST[pos].L, val, BST[pos].val);
        else return queryPost(BST[pos].L, val, res);
    }
}

int queryVal(int pos, int val){
    if(pos == 0) return 0;
    if(val == BST[pos].val)
        return BST[BST[pos].L].siz + 1;
    if(val < BST[pos].val)
        return queryVal(BST[pos].L, val);
    return queryVal(BST[pos].R, val) + BST[BST[pos].L].siz + BST[pos].cnt;
}

int querykth(int pos, int k){
    if(pos == 0) return INF;
    if(BST[BST[pos].L].siz >= k)
        return querykth(BST[pos].L, k);
    if(BST[BST[pos].L].siz + BST[pos].cnt >= k)
        return BST[pos].val;
    return querykth(BST[pos].R, k - BST[BST[pos].L].siz - BST[pos].cnt);
}
```

### 伸展树（splay）
&emsp;&emsp;伸展树是相对简单的一种平衡树。对于 BST 来说，虽然每次操作的最坏情形是 O(n)，只要保证最坏情形相对不常发生就行，这就需要移动每一个被访问的结点（防止连续多次访问深结点累积的运行时间）。splay 通过上旋的方式将每一个访问结点移动至根结点，适用于多次访问的情形，理论上将原本累积的线性时间摊还为对数时间。同时，上旋时还有把访问路径上的大部分结点的深度大致减少一半的效果，优化了访问新结点的时间。

![rotate.png](https://i.loli.net/2020/04/13/dTAv6iu1eyJ47jb.png)

![splay.png](https://i.loli.net/2020/04/13/zXTvQb7GikZtEge.png)

```c++
int root, snt;
const int MAX = (1e+5) + 10;
struct node{
    int father, val, siz, cnt;
    int ch[2];
}sp[MAX];

void update(int pos){
    sp[pos].siz = sp[sp[pos].ch[0]].siz + sp[sp[pos].ch[1]].siz + sp[pos].cnt;
}

int identify(int pos){
    return sp[sp[pos].father].ch[0] == pos? 0 : 1;
}

void connect(int pos, int fa, int son){
    sp[pos].father = fa;
    sp[fa].ch[son] = pos;
}

void rotate(int pos){
    int y = sp[pos].father;
    int R = sp[y].father;
    int Rson = identify(y);
    int yson = identify(pos);
    int B = sp[pos].ch[yson ^ 1];
    connect(B, y, yson); connect(y, pos, (yson ^ 1));
    connect(pos, R, Rson);
    update(y); update(pos);
}

void splay(int pos, int goal){
    while(sp[pos].father != goal){
        int up = sp[pos].father;
        if(sp[up].father == goal)
            rotate(pos);
        else if(identify(up) == identify(pos)){
            rotate(up); rotate(pos);
        }
        else{
            rotate(pos); rotate(pos);
        }
    }
    if(goal == 0)
        root = pos; // 头结点的子结点是树的根
}

void insert(int x){
    int u = root, fa = 0;
    while(u && sp[u].val != x){
        fa = u;
        u = sp[u].ch[x > sp[u].val]; // 大于则右插
    }
    if(u)
        sp[u].cnt++;
    else{
        u = ++snt;
        if(fa)
            sp[fa].ch[x > sp[fa].val] = u;
        sp[snt].ch[0] = sp[snt].ch[1] = 0;
        sp[snt].father = fa; sp[snt].val = x;
        sp[snt].cnt = sp[snt].siz = 1;
    }
    splay(u, 0); // 插入节点上旋至根节点
}

void queryVal(int x){
    int u = root;
    if(!u) return;
    while(sp[u].ch[x > sp[u].val] && x != sp[u].val)
        u = sp[u].ch[x > sp[u].val];
    splay(u, 0);
}

int queryNext(int x, int f){
    queryVal(x);
    int u = root;
    if((sp[u].val > x && f) || (sp[u].val < x && !f))
        return u;
    u = sp[u].ch[f];
    while(sp[u].ch[f ^ 1])
        u = sp[u].ch[f ^ 1];
    return u;
}

void del(int x){
    int pre = queryNext(x, 0);
    int post = queryNext(x, 1);
    // 确保删除结点一定是叶结点
    splay(pre, 0); splay(post, pre);
    int d = sp[post].ch[0];
    if(sp[d].cnt > 1){
        sp[d].cnt--;
        splay(d, 0);
    }
    else sp[post].ch[0] = 0;
}

int query_k(int k){
    int u = root;
    if(sp[u].siz < k)
        return -1;
    while(true){
        int y = sp[u].ch[0];
        if(k > sp[y].siz + sp[u].cnt){
            k -= sp[y].siz + sp[u].cnt;
            u = sp[u].ch[1];
        }
        else if(sp[y].siz >= k)
            u = y;
        else return sp[u].val;
    }
}
```
