---
title: 洛谷之旅（一）
category: ACM
tags:
- ACM
- 算法
---

|前导
|:-:
|输入输出技巧
|零散知识
|模拟和高精度

## 输入输出技巧
1、`printf("%02d", cnt);`，`%02d` 表示将输出数字保留 2 位场宽，不足补 0，超出 2 位则输出原数。`%-2d` 则是以空格补全

2、注意读 0123 和 0 1 2 3 的区别，前者用 char 读，后者用 int 读

3、`cin >> s;` 会忽略前导空白字符，遇到空格/换行跳出； `getline(cin, s);` 读取整行，包括前导和嵌入空格。注意不要混用两者，因为 getline 会读入上一个 cin 遗留的 `\n` 并终止

4、`cin >> noskipws >> c;` ，不跳过空格和换行

5、cin 的骚操作，想读取 int 却读到了 char 可以清空缓冲区并重读：
```c++
char c; int a;

cin >> a;
if(cin.fail()){
    cin.clear();
    cin >> c >> a;
} 
```

6、scanf 会返回成功接收到的变量值
```c++
// 解析 a:=3;b:=a;
while(scanf("%c:=%c;", &c1, &c2) == 2){
    if(c2 >= '0' && c2 <= '9')
        a[c1 - 'a'] = c2 - '0';
    else a[c1 - 'a'] = a[c2 - 'a'];
}
```

## 零散知识点
1、 ~~小写字母 ascii 码 比大写字母大 32~~，可以直接用 `a[c - 'a' + 'A']` 这样的 char 类型运算规避掉 ascii 码的记忆

2、char 和 int 运算得到的结果是 int，如果要用 char 输出的话需要做类型转换

3、字符串匹配使用滑动窗口，追求性能尽量不使用 STL 内置函数

4、字符串基本操作
```c++
#include <string> 
string s; // + 以拼接
s.substr(int index, int len); // 子串
s.insert(int index, string s); // 插入，改变本身
s.find(string sub); // 找到子串位置
s.compare(string sb); // 相等返回 0
s.erase(s.begin(), s.begin() + len);
s.front(); // 首字母
s.back(); // 末字母
toupper(char c);
reverse(s.begin(), s.end());
```

5、数组初始化，打表简化问题
```c++
struct{
    int a, b, c;
}q[1005];

string s[3] = {"abc", "def", "ghi"}
```

6、公约数，尾递归写法减少栈开销
```c++
int gcd(int a, int b){
	return (b == 0)? a : gcd(b, a % b);
}
```

7、埃筛和回文数
```c++
bool p[100000001]; // 节省内存

bool isReverse(int n){
    int tmp = n, ans = 0;
    while(tmp != 0){
        ans = ans * 10 + tmp % 10;
        tmp /= 10;
    }
    return ans == n;
}

void prime(int b){
    p[0] = p[1] = 1;
    for (int i = 2; i * i <= b; i++)
        for (int j = i; i * j <= b; j++)
            p[j * i] = 1;
}
```

8、唯一分解定理：一个数只能分解为一组质数的乘积

## 模拟和高精度
1、矩阵旋转（逆时针 $\theta$），对于非原点处坐标变换可先平移坐标系再进行旋转，常用矩阵子块的旋转

$$
\left[
 \begin{matrix}
   x' \\
   y'
  \end{matrix} 
\right]
=
\left[
 \begin{matrix}
   \cos\theta & -\sin\theta \\
   \sin\theta & \cos\theta
  \end{matrix} 
\right]
\left[
 \begin{matrix}
   x \\
   y
  \end{matrix} 
\right]
$$

2、打表（哈希表）建立映射，该基础上可以有多种变式，需要注意开辟数组的范围
```c++
// 两数之和
int T, maxx, res;
int a[105], k[20005], v[20005];

int main(){
    cin >> T;
    for (int i = 0; i < T; i++){
        cin >> a[i];
        k[a[i]] = 1;
    }
    for (int i = 0; i < T; i++){
        for (int j = i + 1; j < T; j++){
            v[a[i] + a[j]]++;
            maxx = max(maxx, a[i] + a[j]);
        }
    }
    for (int i = 0; i <= maxx; i++)
        if(v[i] > 0 && k[i])
            res++;
    cout << res;
    return 0;
}
```

3、高精加和高精乘模板
```c++
string s1, s2;
int a[2005], b[2005], c[4500];
int len1, len2;
bool flag;

void pplus(int *a, int *b, int n){
    int carry = 0;
    for (int i = 0; i < n; i++){
        b[i] += a[i] + carry;
        carry = b[i] / 10;
        b[i] %= 10; 
    }
}

void times(int *a, int t, int n){
    int carry = 0;
    for (int i = 0; i < n; i++){
        a[i] = a[i] * t + carry;
        carry = a[i] / 10;
        a[i] %= 10;
    }
}

void ttimes(int* a, int* b, int* c, int n){
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            c[i+j] += a[i] * b[j];
            if(c[i+j] >= 10){
                c[i+j+1] += c[i+j] / 10;
                c[i+j] %= 10;
            }
        }
    }
}

int main(){
    cin >> s1 >> s2;
    len1 = s1.size(); len2 = s2.size();
    for(int i = 0; i < len1; i++)
        a[i] = s1[len1 - i - 1] - '0';
    for(int i = 0; i < len2; i++)
        b[i] = s2[len2 - i - 1] - '0';

    // pplus(a, b, 2000);
    ttimes(a, b, c, 2000);

    for(int i = 4001; i >= 0; i--){
        if(c[i] != 0) flag = 1;
        if(flag) cout << c[i];
    }
    if(!flag) cout << 0; // 特判 0
    return 0;
}
```